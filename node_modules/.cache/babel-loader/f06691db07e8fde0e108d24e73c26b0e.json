{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar decode_codepoint_1 = __importDefault(require(\"entities/lib/decode_codepoint\"));\n\nvar decode_1 = require(\"entities/lib/decode\");\n\nfunction isWhitespace(c) {\n  return c === 32\n  /* Space */\n  || c === 10\n  /* NewLine */\n  || c === 9\n  /* Tab */\n  || c === 12\n  /* FormFeed */\n  || c === 13\n  /* CarriageReturn */\n  ;\n}\n\nfunction isEndOfTagSection(c) {\n  return c === 47\n  /* Slash */\n  || c === 62\n  /* Gt */\n  || isWhitespace(c);\n}\n\nfunction isNumber(c) {\n  return c >= 48\n  /* Zero */\n  && c <= 57\n  /* Nine */\n  ;\n}\n\nfunction isASCIIAlpha(c) {\n  return c >= 97\n  /* LowerA */\n  && c <= 122\n  /* LowerZ */\n  || c >= 65\n  /* UpperA */\n  && c <= 90\n  /* UpperZ */\n  ;\n}\n/**\n * Sequences used to match longer strings.\n *\n * We don't have `Script`, `Style`, or `Title` here. Instead, we re-use the *End\n * sequences with an increased offset.\n */\n\n\nvar Sequences = {\n  Cdata: new Uint16Array([0x43, 0x44, 0x41, 0x54, 0x41, 0x5b]),\n  CdataEnd: new Uint16Array([0x5d, 0x5d, 0x3e]),\n  CommentEnd: new Uint16Array([0x2d, 0x2d, 0x3e]),\n  ScriptEnd: new Uint16Array([0x3c, 0x2f, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74]),\n  StyleEnd: new Uint16Array([0x3c, 0x2f, 0x73, 0x74, 0x79, 0x6c, 0x65]),\n  TitleEnd: new Uint16Array([0x3c, 0x2f, 0x74, 0x69, 0x74, 0x6c, 0x65]) // `</title`\n\n};\n\nvar Tokenizer =\n/** @class */\nfunction () {\n  function Tokenizer(_a, cbs) {\n    var _b = _a.xmlMode,\n        xmlMode = _b === void 0 ? false : _b,\n        _c = _a.decodeEntities,\n        decodeEntities = _c === void 0 ? true : _c;\n    this.cbs = cbs;\n    /** The current state the tokenizer is in. */\n\n    this._state = 1\n    /* Text */\n    ;\n    /** The read buffer. */\n\n    this.buffer = \"\";\n    /** The beginning of the section that is currently being read. */\n\n    this.sectionStart = 0;\n    /** The index within the buffer that we are currently looking at. */\n\n    this._index = 0;\n    /**\n     * Data that has already been processed will be removed from the buffer occasionally.\n     * `_bufferOffset` keeps track of how many characters have been removed, to make sure position information is accurate.\n     */\n\n    this.bufferOffset = 0;\n    /** Some behavior, eg. when decoding entities, is done while we are in another state. This keeps track of the other state type. */\n\n    this.baseState = 1\n    /* Text */\n    ;\n    /** For special parsing behavior inside of script and style tags. */\n\n    this.isSpecial = false;\n    /** Indicates whether the tokenizer has been paused. */\n\n    this.running = true;\n    /** Indicates whether the tokenizer has finished running / `.end` has been called. */\n\n    this.ended = false;\n    this.sequenceIndex = 0;\n    this.trieIndex = 0;\n    this.trieCurrent = 0;\n    this.trieResult = null;\n    this.entityExcess = 0;\n    this.xmlMode = xmlMode;\n    this.decodeEntities = decodeEntities;\n    this.entityTrie = xmlMode ? decode_1.xmlDecodeTree : decode_1.htmlDecodeTree;\n  }\n\n  Tokenizer.prototype.reset = function () {\n    this._state = 1\n    /* Text */\n    ;\n    this.buffer = \"\";\n    this.sectionStart = 0;\n    this._index = 0;\n    this.bufferOffset = 0;\n    this.baseState = 1\n    /* Text */\n    ;\n    this.currentSequence = undefined;\n    this.running = true;\n    this.ended = false;\n  };\n\n  Tokenizer.prototype.write = function (chunk) {\n    if (this.ended) return this.cbs.onerror(Error(\".write() after done!\"));\n    this.buffer += chunk;\n    this.parse();\n  };\n\n  Tokenizer.prototype.end = function (chunk) {\n    if (this.ended) return this.cbs.onerror(Error(\".end() after done!\"));\n    if (chunk) this.write(chunk);\n    this.ended = true;\n    if (this.running) this.finish();\n  };\n\n  Tokenizer.prototype.pause = function () {\n    this.running = false;\n  };\n\n  Tokenizer.prototype.resume = function () {\n    this.running = true;\n\n    if (this._index < this.buffer.length) {\n      this.parse();\n    }\n\n    if (this.ended) {\n      this.finish();\n    }\n  };\n  /**\n   * The start of the current section.\n   */\n\n\n  Tokenizer.prototype.getAbsoluteSectionStart = function () {\n    return this.sectionStart + this.bufferOffset;\n  };\n  /**\n   * The current index within all of the written data.\n   */\n\n\n  Tokenizer.prototype.getAbsoluteIndex = function () {\n    return this.bufferOffset + this._index;\n  };\n\n  Tokenizer.prototype.stateText = function (c) {\n    if (c === 60\n    /* Lt */\n    || !this.decodeEntities && this.fastForwardTo(60\n    /* Lt */\n    )) {\n      if (this._index > this.sectionStart) {\n        this.cbs.ontext(this.getSection());\n      }\n\n      this._state = 2\n      /* BeforeTagName */\n      ;\n      this.sectionStart = this._index;\n    } else if (this.decodeEntities && c === 38\n    /* Amp */\n    ) {\n      this._state = 25\n      /* BeforeEntity */\n      ;\n    }\n  };\n\n  Tokenizer.prototype.stateSpecialStartSequence = function (c) {\n    var isEnd = this.sequenceIndex === this.currentSequence.length;\n    var isMatch = isEnd ? // If we are at the end of the sequence, make sure the tag name has ended\n    isEndOfTagSection(c) : // Otherwise, do a case-insensitive comparison\n    (c | 0x20) === this.currentSequence[this.sequenceIndex];\n\n    if (!isMatch) {\n      this.isSpecial = false;\n    } else if (!isEnd) {\n      this.sequenceIndex++;\n      return;\n    }\n\n    this.sequenceIndex = 0;\n    this._state = 3\n    /* InTagName */\n    ;\n    this.stateInTagName(c);\n  };\n  /** Look for an end tag. For <title> tags, also decode entities. */\n\n\n  Tokenizer.prototype.stateInSpecialTag = function (c) {\n    if (this.sequenceIndex === this.currentSequence.length) {\n      if (c === 62\n      /* Gt */\n      || isWhitespace(c)) {\n        var endOfText = this._index - this.currentSequence.length;\n\n        if (this.sectionStart < endOfText) {\n          // Spoof the index so that reported locations match up.\n          var actualIndex = this._index;\n          this._index = endOfText;\n          this.cbs.ontext(this.getSection());\n          this._index = actualIndex;\n        }\n\n        this.isSpecial = false;\n        this.sectionStart = endOfText + 2; // Skip over the `</`\n\n        this.stateInClosingTagName(c);\n        return; // We are done; skip the rest of the function.\n      }\n\n      this.sequenceIndex = 0;\n    }\n\n    if ((c | 0x20) === this.currentSequence[this.sequenceIndex]) {\n      this.sequenceIndex += 1;\n    } else if (this.sequenceIndex === 0) {\n      if (this.currentSequence === Sequences.TitleEnd) {\n        // We have to parse entities in <title> tags.\n        if (this.decodeEntities && c === 38\n        /* Amp */\n        ) {\n          this._state = 25\n          /* BeforeEntity */\n          ;\n        }\n      } else if (this.fastForwardTo(60\n      /* Lt */\n      )) {\n        // Outside of <title> tags, we can fast-forward.\n        this.sequenceIndex = 1;\n      }\n    } else {\n      // If we see a `<`, set the sequence index to 1; useful for eg. `<</script>`.\n      this.sequenceIndex = Number(c === 60\n      /* Lt */\n      );\n    }\n  };\n\n  Tokenizer.prototype.stateCDATASequence = function (c) {\n    if (c === Sequences.Cdata[this.sequenceIndex]) {\n      if (++this.sequenceIndex === Sequences.Cdata.length) {\n        this._state = 21\n        /* InCommentLike */\n        ;\n        this.currentSequence = Sequences.CdataEnd;\n        this.sequenceIndex = 0;\n        this.sectionStart = this._index + 1;\n      }\n    } else {\n      this.sequenceIndex = 0;\n      this._state = 16\n      /* InDeclaration */\n      ;\n      this.stateInDeclaration(c); // Reconsume the character\n    }\n  };\n  /**\n   * When we wait for one specific character, we can speed things up\n   * by skipping through the buffer until we find it.\n   *\n   * @returns Whether the character was found.\n   */\n\n\n  Tokenizer.prototype.fastForwardTo = function (c) {\n    while (++this._index < this.buffer.length) {\n      if (this.buffer.charCodeAt(this._index) === c) {\n        return true;\n      }\n    }\n    /*\n     * We increment the index at the end of the `parse` loop,\n     * so set it to `buffer.length - 1` here.\n     *\n     * TODO: Refactor `parse` to increment index before calling states.\n     */\n\n\n    this._index = this.buffer.length - 1;\n    return false;\n  };\n  /**\n   * Comments and CDATA end with `-->` and `]]>`.\n   *\n   * Their common qualities are:\n   * - Their end sequences have a distinct character they start with.\n   * - That character is then repeated, so we have to check multiple repeats.\n   * - All characters but the start character of the sequence can be skipped.\n   */\n\n\n  Tokenizer.prototype.stateInCommentLike = function (c) {\n    if (c === this.currentSequence[this.sequenceIndex]) {\n      if (++this.sequenceIndex === this.currentSequence.length) {\n        // Remove 2 trailing chars\n        var section = this.buffer.slice(this.sectionStart, this._index - 2);\n\n        if (this.currentSequence === Sequences.CdataEnd) {\n          this.cbs.oncdata(section);\n        } else {\n          this.cbs.oncomment(section);\n        }\n\n        this.sequenceIndex = 0;\n        this.sectionStart = this._index + 1;\n        this._state = 1\n        /* Text */\n        ;\n      }\n    } else if (this.sequenceIndex === 0) {\n      // Fast-forward to the first character of the sequence\n      if (this.fastForwardTo(this.currentSequence[0])) {\n        this.sequenceIndex = 1;\n      }\n    } else if (c !== this.currentSequence[this.sequenceIndex - 1]) {\n      // Allow long sequences, eg. --->, ]]]>\n      this.sequenceIndex = 0;\n    }\n  };\n  /**\n   * HTML only allows ASCII alpha characters (a-z and A-Z) at the beginning of a tag name.\n   *\n   * XML allows a lot more characters here (@see https://www.w3.org/TR/REC-xml/#NT-NameStartChar).\n   * We allow anything that wouldn't end the tag.\n   */\n\n\n  Tokenizer.prototype.isTagStartChar = function (c) {\n    return this.xmlMode ? !isEndOfTagSection(c) : isASCIIAlpha(c);\n  };\n\n  Tokenizer.prototype.startSpecial = function (sequence, offset) {\n    this.isSpecial = true;\n    this.currentSequence = sequence;\n    this.sequenceIndex = offset;\n    this._state = 23\n    /* SpecialStartSequence */\n    ;\n  };\n\n  Tokenizer.prototype.stateBeforeTagName = function (c) {\n    if (c === 33\n    /* ExclamationMark */\n    ) {\n      this._state = 15\n      /* BeforeDeclaration */\n      ;\n      this.sectionStart = this._index + 1;\n    } else if (c === 63\n    /* Questionmark */\n    ) {\n      this._state = 17\n      /* InProcessingInstruction */\n      ;\n      this.sectionStart = this._index + 1;\n    } else if (this.isTagStartChar(c)) {\n      var lower = c | 0x20;\n      this.sectionStart = this._index;\n\n      if (!this.xmlMode && lower === Sequences.TitleEnd[2]) {\n        this.startSpecial(Sequences.TitleEnd, 3);\n      } else {\n        this._state = !this.xmlMode && lower === Sequences.ScriptEnd[2] ? 22\n        /* BeforeSpecialS */\n        : 3\n        /* InTagName */\n        ;\n      }\n    } else if (c === 47\n    /* Slash */\n    ) {\n      this._state = 5\n      /* BeforeClosingTagName */\n      ;\n    } else {\n      this._state = 1\n      /* Text */\n      ;\n      this.stateText(c);\n    }\n  };\n\n  Tokenizer.prototype.stateInTagName = function (c) {\n    if (isEndOfTagSection(c)) {\n      this.cbs.onopentagname(this.getSection());\n      this.sectionStart = -1;\n      this._state = 8\n      /* BeforeAttributeName */\n      ;\n      this.stateBeforeAttributeName(c);\n    }\n  };\n\n  Tokenizer.prototype.stateBeforeClosingTagName = function (c) {\n    if (isWhitespace(c)) {// Ignore\n    } else if (c === 62\n    /* Gt */\n    ) {\n      this._state = 1\n      /* Text */\n      ;\n    } else {\n      this._state = this.isTagStartChar(c) ? 6\n      /* InClosingTagName */\n      : 20\n      /* InSpecialComment */\n      ;\n      this.sectionStart = this._index;\n    }\n  };\n\n  Tokenizer.prototype.stateInClosingTagName = function (c) {\n    if (c === 62\n    /* Gt */\n    || isWhitespace(c)) {\n      this.cbs.onclosetag(this.getSection());\n      this.sectionStart = -1;\n      this._state = 7\n      /* AfterClosingTagName */\n      ;\n      this.stateAfterClosingTagName(c);\n    }\n  };\n\n  Tokenizer.prototype.stateAfterClosingTagName = function (c) {\n    // Skip everything until \">\"\n    if (c === 62\n    /* Gt */\n    || this.fastForwardTo(62\n    /* Gt */\n    )) {\n      this._state = 1\n      /* Text */\n      ;\n      this.sectionStart = this._index + 1;\n    }\n  };\n\n  Tokenizer.prototype.stateBeforeAttributeName = function (c) {\n    if (c === 62\n    /* Gt */\n    ) {\n      this.cbs.onopentagend();\n\n      if (this.isSpecial) {\n        this._state = 24\n        /* InSpecialTag */\n        ;\n        this.sequenceIndex = 0;\n      } else {\n        this._state = 1\n        /* Text */\n        ;\n      }\n\n      this.baseState = this._state;\n      this.sectionStart = this._index + 1;\n    } else if (c === 47\n    /* Slash */\n    ) {\n      this._state = 4\n      /* InSelfClosingTag */\n      ;\n    } else if (!isWhitespace(c)) {\n      this._state = 9\n      /* InAttributeName */\n      ;\n      this.sectionStart = this._index;\n    }\n  };\n\n  Tokenizer.prototype.stateInSelfClosingTag = function (c) {\n    if (c === 62\n    /* Gt */\n    ) {\n      this.cbs.onselfclosingtag();\n      this._state = 1\n      /* Text */\n      ;\n      this.baseState = 1\n      /* Text */\n      ;\n      this.sectionStart = this._index + 1;\n      this.isSpecial = false; // Reset special state, in case of self-closing special tags\n    } else if (!isWhitespace(c)) {\n      this._state = 8\n      /* BeforeAttributeName */\n      ;\n      this.stateBeforeAttributeName(c);\n    }\n  };\n\n  Tokenizer.prototype.stateInAttributeName = function (c) {\n    if (c === 61\n    /* Eq */\n    || isEndOfTagSection(c)) {\n      this.cbs.onattribname(this.getSection());\n      this.sectionStart = -1;\n      this._state = 10\n      /* AfterAttributeName */\n      ;\n      this.stateAfterAttributeName(c);\n    }\n  };\n\n  Tokenizer.prototype.stateAfterAttributeName = function (c) {\n    if (c === 61\n    /* Eq */\n    ) {\n      this._state = 11\n      /* BeforeAttributeValue */\n      ;\n    } else if (c === 47\n    /* Slash */\n    || c === 62\n    /* Gt */\n    ) {\n      this.cbs.onattribend(undefined);\n      this._state = 8\n      /* BeforeAttributeName */\n      ;\n      this.stateBeforeAttributeName(c);\n    } else if (!isWhitespace(c)) {\n      this.cbs.onattribend(undefined);\n      this._state = 9\n      /* InAttributeName */\n      ;\n      this.sectionStart = this._index;\n    }\n  };\n\n  Tokenizer.prototype.stateBeforeAttributeValue = function (c) {\n    if (c === 34\n    /* DoubleQuote */\n    ) {\n      this._state = 12\n      /* InAttributeValueDq */\n      ;\n      this.sectionStart = this._index + 1;\n    } else if (c === 39\n    /* SingleQuote */\n    ) {\n      this._state = 13\n      /* InAttributeValueSq */\n      ;\n      this.sectionStart = this._index + 1;\n    } else if (!isWhitespace(c)) {\n      this.sectionStart = this._index;\n      this._state = 14\n      /* InAttributeValueNq */\n      ;\n      this.stateInAttributeValueNoQuotes(c); // Reconsume token\n    }\n  };\n\n  Tokenizer.prototype.handleInAttributeValue = function (c, quote) {\n    if (c === quote || !this.decodeEntities && this.fastForwardTo(quote)) {\n      this.cbs.onattribdata(this.getSection());\n      this.sectionStart = -1;\n      this.cbs.onattribend(String.fromCharCode(quote));\n      this._state = 8\n      /* BeforeAttributeName */\n      ;\n    } else if (this.decodeEntities && c === 38\n    /* Amp */\n    ) {\n      this.baseState = this._state;\n      this._state = 25\n      /* BeforeEntity */\n      ;\n    }\n  };\n\n  Tokenizer.prototype.stateInAttributeValueDoubleQuotes = function (c) {\n    this.handleInAttributeValue(c, 34\n    /* DoubleQuote */\n    );\n  };\n\n  Tokenizer.prototype.stateInAttributeValueSingleQuotes = function (c) {\n    this.handleInAttributeValue(c, 39\n    /* SingleQuote */\n    );\n  };\n\n  Tokenizer.prototype.stateInAttributeValueNoQuotes = function (c) {\n    if (isWhitespace(c) || c === 62\n    /* Gt */\n    ) {\n      this.cbs.onattribdata(this.getSection());\n      this.sectionStart = -1;\n      this.cbs.onattribend(null);\n      this._state = 8\n      /* BeforeAttributeName */\n      ;\n      this.stateBeforeAttributeName(c);\n    } else if (this.decodeEntities && c === 38\n    /* Amp */\n    ) {\n      this.baseState = this._state;\n      this._state = 25\n      /* BeforeEntity */\n      ;\n    }\n  };\n\n  Tokenizer.prototype.stateBeforeDeclaration = function (c) {\n    if (c === 91\n    /* OpeningSquareBracket */\n    ) {\n      this._state = 19\n      /* CDATASequence */\n      ;\n      this.sequenceIndex = 0;\n    } else {\n      this._state = c === 45\n      /* Dash */\n      ? 18\n      /* BeforeComment */\n      : 16\n      /* InDeclaration */\n      ;\n    }\n  };\n\n  Tokenizer.prototype.stateInDeclaration = function (c) {\n    if (c === 62\n    /* Gt */\n    || this.fastForwardTo(62\n    /* Gt */\n    )) {\n      this.cbs.ondeclaration(this.getSection());\n      this._state = 1\n      /* Text */\n      ;\n      this.sectionStart = this._index + 1;\n    }\n  };\n\n  Tokenizer.prototype.stateInProcessingInstruction = function (c) {\n    if (c === 62\n    /* Gt */\n    || this.fastForwardTo(62\n    /* Gt */\n    )) {\n      this.cbs.onprocessinginstruction(this.getSection());\n      this._state = 1\n      /* Text */\n      ;\n      this.sectionStart = this._index + 1;\n    }\n  };\n\n  Tokenizer.prototype.stateBeforeComment = function (c) {\n    if (c === 45\n    /* Dash */\n    ) {\n      this._state = 21\n      /* InCommentLike */\n      ;\n      this.currentSequence = Sequences.CommentEnd; // Allow short comments (eg. <!-->)\n\n      this.sequenceIndex = 2;\n      this.sectionStart = this._index + 1;\n    } else {\n      this._state = 16\n      /* InDeclaration */\n      ;\n    }\n  };\n\n  Tokenizer.prototype.stateInSpecialComment = function (c) {\n    if (c === 62\n    /* Gt */\n    || this.fastForwardTo(62\n    /* Gt */\n    )) {\n      this.cbs.oncomment(this.getSection());\n      this._state = 1\n      /* Text */\n      ;\n      this.sectionStart = this._index + 1;\n    }\n  };\n\n  Tokenizer.prototype.stateBeforeSpecialS = function (c) {\n    var lower = c | 0x20;\n\n    if (lower === Sequences.ScriptEnd[3]) {\n      this.startSpecial(Sequences.ScriptEnd, 4);\n    } else if (lower === Sequences.StyleEnd[3]) {\n      this.startSpecial(Sequences.StyleEnd, 4);\n    } else {\n      this._state = 3\n      /* InTagName */\n      ;\n      this.stateInTagName(c); // Consume the token again\n    }\n  };\n\n  Tokenizer.prototype.stateBeforeEntity = function (c) {\n    // Start excess with 1 to include the '&'\n    this.entityExcess = 1;\n\n    if (c === 35\n    /* Num */\n    ) {\n      this._state = 26\n      /* BeforeNumericEntity */\n      ;\n    } else if (c === 38\n    /* Amp */\n    ) {// We have two `&` characters in a row. Stay in the current state.\n    } else {\n      this.trieIndex = 0;\n      this.trieCurrent = this.entityTrie[0];\n      this.trieResult = null;\n      this._state = 27\n      /* InNamedEntity */\n      ;\n      this.stateInNamedEntity(c);\n    }\n  };\n\n  Tokenizer.prototype.stateInNamedEntity = function (c) {\n    this.entityExcess += 1;\n    this.trieIndex = (0, decode_1.determineBranch)(this.entityTrie, this.trieCurrent, this.trieIndex + 1, c);\n\n    if (this.trieIndex < 0) {\n      this.emitNamedEntity();\n      this._index--;\n      return;\n    }\n\n    this.trieCurrent = this.entityTrie[this.trieIndex]; // If the branch is a value, store it and continue\n\n    if (this.trieCurrent & decode_1.BinTrieFlags.HAS_VALUE) {\n      // If we have a legacy entity while parsing strictly, just skip the number of bytes\n      if (!this.allowLegacyEntity() && c !== 59\n      /* Semi */\n      ) {\n        // No need to consider multi-byte values, as the legacy entity is always a single byte\n        this.trieIndex += 1;\n      } else {\n        // Add 1 as we have already incremented the excess\n        var entityStart = this._index - this.entityExcess + 1;\n\n        if (entityStart > this.sectionStart) {\n          this.emitPartial(this.buffer.substring(this.sectionStart, entityStart));\n        } // If this is a surrogate pair, combine the higher bits from the node with the next byte\n\n\n        this.trieResult = this.trieCurrent & decode_1.BinTrieFlags.MULTI_BYTE ? String.fromCharCode(this.entityTrie[++this.trieIndex], this.entityTrie[++this.trieIndex]) : String.fromCharCode(this.entityTrie[++this.trieIndex]);\n        this.entityExcess = 0;\n        this.sectionStart = this._index + 1;\n      }\n    }\n  };\n\n  Tokenizer.prototype.emitNamedEntity = function () {\n    if (this.trieResult) {\n      this.emitPartial(this.trieResult);\n    }\n\n    this._state = this.baseState;\n  };\n\n  Tokenizer.prototype.stateBeforeNumericEntity = function (c) {\n    if ((c | 0x20) === 120\n    /* LowerX */\n    ) {\n      this.entityExcess++;\n      this._state = 29\n      /* InHexEntity */\n      ;\n    } else {\n      this._state = 28\n      /* InNumericEntity */\n      ;\n      this.stateInNumericEntity(c);\n    }\n  };\n\n  Tokenizer.prototype.decodeNumericEntity = function (base, strict) {\n    var entityStart = this._index - this.entityExcess - 1;\n    var numberStart = entityStart + 2 + (base >> 4);\n\n    if (numberStart !== this._index) {\n      // Emit leading data if any\n      if (entityStart > this.sectionStart) {\n        this.emitPartial(this.buffer.substring(this.sectionStart, entityStart));\n      } // Parse entity\n\n\n      var entity = this.buffer.substring(numberStart, this._index);\n      var parsed = parseInt(entity, base);\n      this.emitPartial((0, decode_codepoint_1.default)(parsed));\n      this.sectionStart = this._index + Number(strict);\n    }\n\n    this._state = this.baseState;\n  };\n\n  Tokenizer.prototype.stateInNumericEntity = function (c) {\n    if (c === 59\n    /* Semi */\n    ) {\n      this.decodeNumericEntity(10, true);\n    } else if (!isNumber(c)) {\n      if (this.allowLegacyEntity()) {\n        this.decodeNumericEntity(10, false);\n      } else {\n        this._state = this.baseState;\n      }\n\n      this._index--;\n    } else {\n      this.entityExcess++;\n    }\n  };\n\n  Tokenizer.prototype.stateInHexEntity = function (c) {\n    if (c === 59\n    /* Semi */\n    ) {\n      this.decodeNumericEntity(16, true);\n    } else if ((c < 97\n    /* LowerA */\n    || c > 102\n    /* LowerF */\n    ) && (c < 65\n    /* UpperA */\n    || c > 70\n    /* UpperF */\n    ) && !isNumber(c)) {\n      if (this.allowLegacyEntity()) {\n        this.decodeNumericEntity(16, false);\n      } else {\n        this._state = this.baseState;\n      }\n\n      this._index--;\n    } else {\n      this.entityExcess++;\n    }\n  };\n\n  Tokenizer.prototype.allowLegacyEntity = function () {\n    return !this.xmlMode && (this.baseState === 1\n    /* Text */\n    || this.baseState === 24\n    /* InSpecialTag */\n    );\n  };\n  /**\n   * Remove data that has already been consumed from the buffer.\n   */\n\n\n  Tokenizer.prototype.cleanup = function () {\n    // If we are inside of text, emit what we already have.\n    if (this.running && this.sectionStart !== this._index && (this._state === 1\n    /* Text */\n    || this._state === 24\n    /* InSpecialTag */\n    && this.sequenceIndex === 0)) {\n      // TODO: We could emit attribute data here as well.\n      this.cbs.ontext(this.buffer.substr(this.sectionStart));\n      this.sectionStart = this._index;\n    }\n\n    var start = this.sectionStart < 0 ? this._index : this.sectionStart;\n    this.buffer = start === this.buffer.length ? \"\" : this.buffer.substr(start);\n    this._index -= start;\n    this.bufferOffset += start;\n\n    if (this.sectionStart > 0) {\n      this.sectionStart = 0;\n    }\n  };\n\n  Tokenizer.prototype.shouldContinue = function () {\n    return this._index < this.buffer.length && this.running;\n  };\n  /**\n   * Iterates through the buffer, calling the function corresponding to the current state.\n   *\n   * States that are more likely to be hit are higher up, as a performance improvement.\n   */\n\n\n  Tokenizer.prototype.parse = function () {\n    while (this.shouldContinue()) {\n      var c = this.buffer.charCodeAt(this._index);\n\n      if (this._state === 1\n      /* Text */\n      ) {\n        this.stateText(c);\n      } else if (this._state === 23\n      /* SpecialStartSequence */\n      ) {\n        this.stateSpecialStartSequence(c);\n      } else if (this._state === 24\n      /* InSpecialTag */\n      ) {\n        this.stateInSpecialTag(c);\n      } else if (this._state === 19\n      /* CDATASequence */\n      ) {\n        this.stateCDATASequence(c);\n      } else if (this._state === 12\n      /* InAttributeValueDq */\n      ) {\n        this.stateInAttributeValueDoubleQuotes(c);\n      } else if (this._state === 9\n      /* InAttributeName */\n      ) {\n        this.stateInAttributeName(c);\n      } else if (this._state === 21\n      /* InCommentLike */\n      ) {\n        this.stateInCommentLike(c);\n      } else if (this._state === 20\n      /* InSpecialComment */\n      ) {\n        this.stateInSpecialComment(c);\n      } else if (this._state === 8\n      /* BeforeAttributeName */\n      ) {\n        this.stateBeforeAttributeName(c);\n      } else if (this._state === 3\n      /* InTagName */\n      ) {\n        this.stateInTagName(c);\n      } else if (this._state === 6\n      /* InClosingTagName */\n      ) {\n        this.stateInClosingTagName(c);\n      } else if (this._state === 2\n      /* BeforeTagName */\n      ) {\n        this.stateBeforeTagName(c);\n      } else if (this._state === 10\n      /* AfterAttributeName */\n      ) {\n        this.stateAfterAttributeName(c);\n      } else if (this._state === 13\n      /* InAttributeValueSq */\n      ) {\n        this.stateInAttributeValueSingleQuotes(c);\n      } else if (this._state === 11\n      /* BeforeAttributeValue */\n      ) {\n        this.stateBeforeAttributeValue(c);\n      } else if (this._state === 5\n      /* BeforeClosingTagName */\n      ) {\n        this.stateBeforeClosingTagName(c);\n      } else if (this._state === 7\n      /* AfterClosingTagName */\n      ) {\n        this.stateAfterClosingTagName(c);\n      } else if (this._state === 22\n      /* BeforeSpecialS */\n      ) {\n        this.stateBeforeSpecialS(c);\n      } else if (this._state === 14\n      /* InAttributeValueNq */\n      ) {\n        this.stateInAttributeValueNoQuotes(c);\n      } else if (this._state === 4\n      /* InSelfClosingTag */\n      ) {\n        this.stateInSelfClosingTag(c);\n      } else if (this._state === 16\n      /* InDeclaration */\n      ) {\n        this.stateInDeclaration(c);\n      } else if (this._state === 15\n      /* BeforeDeclaration */\n      ) {\n        this.stateBeforeDeclaration(c);\n      } else if (this._state === 18\n      /* BeforeComment */\n      ) {\n        this.stateBeforeComment(c);\n      } else if (this._state === 17\n      /* InProcessingInstruction */\n      ) {\n        this.stateInProcessingInstruction(c);\n      } else if (this._state === 27\n      /* InNamedEntity */\n      ) {\n        this.stateInNamedEntity(c);\n      } else if (this._state === 25\n      /* BeforeEntity */\n      ) {\n        this.stateBeforeEntity(c);\n      } else if (this._state === 29\n      /* InHexEntity */\n      ) {\n        this.stateInHexEntity(c);\n      } else if (this._state === 28\n      /* InNumericEntity */\n      ) {\n        this.stateInNumericEntity(c);\n      } else {\n        // `this._state === State.BeforeNumericEntity`\n        this.stateBeforeNumericEntity(c);\n      }\n\n      this._index++;\n    }\n\n    this.cleanup();\n  };\n\n  Tokenizer.prototype.finish = function () {\n    if (this._state === 27\n    /* InNamedEntity */\n    ) {\n      this.emitNamedEntity();\n    } // If there is remaining data, emit it in a reasonable way\n\n\n    if (this.sectionStart < this._index) {\n      this.handleTrailingData();\n    }\n\n    this.cbs.onend();\n  };\n  /** Handle any trailing data. */\n\n\n  Tokenizer.prototype.handleTrailingData = function () {\n    var data = this.buffer.substr(this.sectionStart);\n\n    if (this._state === 21\n    /* InCommentLike */\n    ) {\n      if (this.currentSequence === Sequences.CdataEnd) {\n        this.cbs.oncdata(data);\n      } else {\n        this.cbs.oncomment(data);\n      }\n    } else if (this._state === 28\n    /* InNumericEntity */\n    && this.allowLegacyEntity()) {\n      this.decodeNumericEntity(10, false); // All trailing data will have been consumed\n    } else if (this._state === 29\n    /* InHexEntity */\n    && this.allowLegacyEntity()) {\n      this.decodeNumericEntity(16, false); // All trailing data will have been consumed\n    } else if (this._state === 3\n    /* InTagName */\n    || this._state === 8\n    /* BeforeAttributeName */\n    || this._state === 11\n    /* BeforeAttributeValue */\n    || this._state === 10\n    /* AfterAttributeName */\n    || this._state === 9\n    /* InAttributeName */\n    || this._state === 13\n    /* InAttributeValueSq */\n    || this._state === 12\n    /* InAttributeValueDq */\n    || this._state === 14\n    /* InAttributeValueNq */\n    || this._state === 6\n    /* InClosingTagName */\n    ) {\n      /*\n       * If we are currently in an opening or closing tag, us not calling the\n       * respective callback signals that the tag should be ignored.\n       */\n    } else {\n      this.cbs.ontext(data);\n    }\n  };\n\n  Tokenizer.prototype.getSection = function () {\n    return this.buffer.substring(this.sectionStart, this._index);\n  };\n\n  Tokenizer.prototype.emitPartial = function (value) {\n    if (this.baseState !== 1\n    /* Text */\n    && this.baseState !== 24\n    /* InSpecialTag */\n    ) {\n      this.cbs.onattribdata(value);\n    } else {\n      this.cbs.ontext(value);\n    }\n  };\n\n  return Tokenizer;\n}();\n\nexports.default = Tokenizer;","map":null,"metadata":{},"sourceType":"script"}